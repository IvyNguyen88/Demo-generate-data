import { CohereClient } from 'cohere-ai';
import * as fs from 'fs/promises';
import * as path from 'path';
import readline from 'readline/promises';
import { stdin as input, stdout as output } from 'process';

export class ScenarioGenerator {
  private cohere: CohereClient;
  private rl: readline.Interface;

  constructor(apiKey: string) {
    this.cohere = new CohereClient({ token: apiKey });
    this.rl = readline.createInterface({ input, output });
  }

  async askQuestion(query: string): Promise<string> {
    try {
      const answer = await this.rl.question(query);
      return answer.trim();
    } catch (error) {
      console.error('Error reading input:', error);
      return '';
    }
  }

  async generateCucumberBDD(requirement: string): Promise<string> {
    try {
      const parsedRequirements = this.extractRequirements(requirement);
      const formattedPrompt = this.buildDynamicPrompt(parsedRequirements);

      const response = await this.cohere.chat({
        message: formattedPrompt,
        model: 'command-nightly',
        maxTokens: 400,
        temperature: 0.7,
      });

      let generatedText = response.text.trim();
      generatedText = this.cleanUpBDDResponse(generatedText);
      return this.correctBDDFormat(generatedText, 'login functionality');
    } catch (error) {
      console.error('Error generating BDD scenario:', (error as Error).message);
      throw error;
    }
  }

  private extractRequirements(input: string): string[] {
    return input
      .split(/[\n,•\-–]+/)
      .map(req => req.trim())
      .filter(req => req.length > 0);
  }

  private buildDynamicPrompt(requirements: string[]): string {
    const list = requirements.map(req => `- ${req}`).join('\n');

    return `Generate a Cucumber BDD feature file in Gherkin syntax for the login functionality with the following requirements:
${list}

Include:
- A Feature description
- Background step if applicable
- One Scenario per requirement
- Use Given, When, Then, And steps properly.`;
  }

  private cleanUpBDDResponse(bddScenario: string): string {
    return bddScenario
      .replace(/```/g, '')
      .replace(/^\s+|\s+$/g, '')
      .replace(/\n+/g, '\n');
  }

  private correctBDDFormat(bddScenario: string, featureTitle: string): string {
    const featureHeader = `Feature: ${featureTitle.charAt(0).toUpperCase() + featureTitle.slice(1)}\n\n`;

    return featureHeader + bddScenario
      .split('\n')
      .map(line => {
        if (line.startsWith('Scenario:')) return `  ${line.trim()}`;
        if (line.match(/^(Given|When|Then|And|But)/)) return `    ${line.trim()}`;
        return line.trim();
      })
      .join('\n');
  }

  async saveBDDScenarioToFile(comment: string, fileName: string, filePathParam: string): Promise<void> {
    let isSatisfied = false;
    let userComment = comment;

    try {
      while (!isSatisfied) {
        const scenario = await this.generateCucumberBDD(userComment);
        console.log('\nGenerated Scenario:\n', scenario);

        let userInput = await this.askQuestion('\nAre you satisfied with this test case? (yes/no): ');

        if (!userInput) {
          console.log('No input provided. Please answer "yes" or "no".');
          continue;
        }

        userInput = userInput.toLowerCase();

        if (userInput === 'yes') {
          isSatisfied = true;
          const featureFilePath = path.join(filePathParam, `${fileName}.feature`);
          await fs.mkdir(filePathParam, { recursive: true });
          await fs.writeFile(featureFilePath, `${scenario.trim()}\n`);
          console.log(`\n✅ BDD scenario saved to: ${featureFilePath}`);
        } else if (userInput === 'no') {
          userComment = await this.askQuestion('Please provide your updated requirement: ');
        } else {
          console.log('Invalid input. Please answer "yes" or "no".');
        }
      }
    } catch (error) {
      console.error('Fatal error during generation/saving:', error);
    } finally {
      this.rl.close();
    }
  }
}

