import { faker } from '@faker-js/faker';

export const generateFakeData = async (options: any): Promise<object[] | string> => {
    const fields = options.fields;
    const volume = options.volume;
    const constraints = options.constraints;

    // Parse constraints
    const parsedConstraints: { [key: string]: { min: number; max: number } } = {};
    if (constraints) {
        constraints.split(',').forEach((constraint: string) => {
            const [field, range] = constraint.trim().split(' between ');
            const [min, max] = range.split(' and ').map(Number);
            parsedConstraints[field] = { min, max };
        });
    }

    // Generic field generation function
    const generateFieldValue = (field: string): string => {
        if (parsedConstraints[field]) {
            const { min, max } = parsedConstraints[field];
            return `${faker.number.int({ min, max })}`;
        }

        // Fallback to default generation based on field name
        switch (field) {
            case 'name':
            case 'username':
                return faker.person.fullName();
            case 'age':
            case 'score':
                return `${faker.number.int({ min: 0, max: 100 })}`;
            case 'address':
            case 'location':
                return faker.location.streetAddress();
            case 'email':
                return faker.internet.email();
            default:
                // Fallback for completely unknown fields
                return faker.string.alphanumeric(10);
        }
    };

    if (options.format === "JSON") {
        return Array.from({ length: volume }, () => {
            const record: any = {};
            fields.forEach(field => {
                record[field] = generateFieldValue(field);
            });
            return record;
        });
    } else if (options.format === "CSV") {
        const csvHeader = fields.join(',');
        const csvRows = Array.from({ length: volume }, () =>
            fields.map(field => generateFieldValue(field)).join(',')
        ).join('\n');
        return `${csvHeader}\n${csvRows}`;
    } else {
        throw new Error(`Unsupported format: ${options.format}`);
    }
};
