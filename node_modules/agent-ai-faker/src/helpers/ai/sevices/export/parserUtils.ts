// parserUtils.ts

// CSV parser
export const parseCsv = (csvString: string): object[] => {
    const records: object[] = [];
    const lines = csvString.trim().split('\n');

    if (lines.length < 2) {
        throw new Error('Invalid CSV format: missing headers or records.');
    }

    const headers = lines[0].split(',').map((header) => header.trim());
    for (let i = 1; i < lines.length; i++) {
        const row = lines[i].split(',');
        if (row.length === headers.length) {
            const record: any = {};
            headers.forEach((header, index) => {
                record[header] = row[index].trim();
            });
            records.push(record);
        } else {
            console.warn(`Skipping malformed row at line ${i + 1}: ${lines[i]}`);
        }
    }

    return records;
};

// Preprocess CSV string to remove descriptive text and empty lines
export const preprocessCsv = (csvString: string): string => {
    const lines = csvString.split('\n');
    const filteredLines = lines.filter(line =>
        !line.trim().startsWith('Here is the generated CSV data') &&
        !line.trim().startsWith('Please note that these are hypothetical details') &&
        line.trim() !== ''
    );
    return filteredLines.join('\n');
};

// Parse data based on format
export const parseData = (data: string | object[], format: string): object[] => {
    if (typeof data === 'string') {
        if (format === 'CSV') {
            const cleanedCsv = preprocessCsv(data);
            return parseCsv(cleanedCsv);
        } else if (format === 'JSON') {
            return JSON.parse(data);
        } else if (format === 'plain text') {
            // Wrap plain text in an object to maintain array consistency
            return [{ text: data }]; 
        } else {
            throw new Error(`Unsupported format for parsing: ${format}`);
        }
    } else if (Array.isArray(data)) {
        return data;
    } else {
        throw new Error('Generated data is in an unsupported format.');
    }
};
